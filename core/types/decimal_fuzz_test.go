// Code generated by llm-fuzzer; DO NOT EDIT.
package types_test

import (
	"testing"

	types "github.com/kwilteam/kwil-db/core/types"
)

func FuzzParseDecimal(f *testing.F) {
	// Seed inputs for fuzzing
	var testcases = []struct {
		s string
	}{
		{"123.45"},
		{"0.001"},
		{"-9876.54321"},
		{"0"},
		{".123"},
		{"1000"},
		{"-0.00001"},
		{"999999999999.9999"},
		{"12345678901234567890.1234567890"},
		{".-1"},
		{".-1e100"},
	}

	for _, tc := range testcases {
		f.Add(tc.s)
	}

	f.Fuzz(func(t *testing.T, s string) {
		// Add necessary setup and initialization

		// Call the function being tested
		_, err := types.ParseDecimal(s)
		// if returns error and error is not nil, short circuit
		if err != nil {
			return
		}
	})
}

func FuzzParseDecimalExplicit(f *testing.F) {
	// Seed inputs for fuzzing
	var testcases = []struct {
		s         string
		precision uint16
		scale     uint16
	}{
		{"123.45", 5, 2},
		{"0.001", 4, 3},
		{"-9876.54321", 10, 5},
		{"0", 1, 0},
		{".123", 3, 3},
		{"1000", 4, 0},
		{"-0.00001", 6, 5},
		{"999999999999.9999", 16, 4},
		{"12345678901234567890.1234567890", 30, 10},
		{".-1", 153, 103},
	}

	for _, tc := range testcases {
		f.Add(tc.s, tc.precision, tc.scale)
	}

	f.Fuzz(func(t *testing.T, s string, precision, scale uint16) {
		// Add necessary setup and initialization

		// Call the function being tested
		_, err := types.ParseDecimalExplicit(s, precision, scale)
		// if returns error and error is not nil, short circuit
		if err != nil {
			return
		}
	})
}
